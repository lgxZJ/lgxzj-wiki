{"version":3,"sources":["LineChart.js","MachinePage.js","App.js","serviceWorker.js","index.js"],"names":["LineChart","xFieldName","this","props","yFieldName","pointsData","config","title","visible","text","description","desc","xField","yField","seriesField","data","padding","forceFit","label","type","point","size","shape","style","fill","stroke","lineWidth","legend","position","yAxis","React","Component","axios","require","default","MachinePage","state","loading","queryUrl","chartDataArray","min","max","tickCount","fetchData","bind","fetchCpuData","genQueryTimeRange","setInterval","timestampEnd","Math","floor","Date","now","start","end","step","timestamp","Format","strValue","parseInt","res","result","row","rowIdx","col","colIdx","setState","preState","newState","JSON","parse","stringify","timeRange","get","params","query","then","machineResult","getResultFromResponse","machineDataChart","forEach","cpuData","cpuIdx","cpuDataValues","values","cpuName","metric","cpu","pointDate","unixTimestamp2DateFormat","cpuUsage","stringValue2Int","push","updateChartData2State","catch","err","console","log","inputs","unitTranslator","labelAppender","totalPromise","input","Promise","all","resArray","totalResult","resIdx","dataEle","value","appendLabelPart","fetchDataParallel","fetchMemDataParallel","device","fetchDiskIODataParallel","fetchMemData","fetchDiskIOData","fetchDiskCapacityData","fetchNetworkIOData","rows","i","length","cols","j","colKey","toString","key","span","rowKey","gutter","prototype","fmt","o","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","k","test","replace","RegExp","$1","getFullYear","substr","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.aa6f6ef3.chunk.js","sourcesContent":["import React from 'react';\nimport { Line } from '@ant-design/charts';\n\nclass LineChart extends React.Component {\n    render() {\n        const xFieldName = this.props.xFieldName;\n        const yFieldName = this.props.yFieldName;\n        const pointsData = this.props.pointsData;\n        const chartTitle = this.props.title;\n        const chartDesc  = this.props.desc;\n        const seriesField = this.props.seriesField;\n\n        const config = {\n            title: {\n                visible: true,\n                text: chartTitle,\n            },\n            description: {\n                visible: true,\n                text: chartDesc,\n            },\n            xField: xFieldName,\n            yField: yFieldName,\n            seriesField,\n            data: pointsData,\n\n            padding: 'auto',\n            forceFit: true,\n            label: {\n                visible: true,\n                type: 'point',\n            },\n            point: {\n                visible: true,\n                size: 2,\n                shape: 'circle',\n                style: {\n                    fill: 'white',\n                    stroke: '#2593fc',\n                    lineWidth: 2,\n                },\n            },\n            legend: { position: 'right-top' },\n            yAxis: this.props.yAxis,\n        };\n\n        return (\n            <div>\n                <Line {...config} />;\n            </div>\n        );\n    }\n}\n\nexport default LineChart;","import React from 'react';\nimport { Row, Col } from 'antd';\n\nimport LineChart from './LineChart';\n\nimport 'antd/dist/antd.css';\n\n\nconst axios = require('axios').default;\n\nclass MachinePage extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            loading: true,\n\n            xFieldName: \"x\",\n            yFieldName: \"y\",\n            seriesField: 'type',\n            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n            chartDataArray: [\n                [\n                    {\n                        pointsData: [],\n                        type: 'cpu',\n                        title: \"CPU 负载\",\n                        desc: \"按cpu分组的负载率\",\n                        yAxis: {\n                            visible: true,\n                            min: 0,\n                            max: 110,\n                            tickCount: 5,\n                        },\n                    },\n                    {\n                        pointsData: [],\n                        type: 'mem',\n                        title: \"内存 负载\",\n                        desc: \"内存资源使用情况，单位MB\",\n                        yAxis: {\n                            visible: true,\n                            min: 0,\n                            max: 4400,\n                            tickCount: 5,\n                        },\n                    },\n                    {\n                        pointsData: [],\n                        type: 'net_io',\n                        title: \"网络 IO\",\n                        desc: \"网络收发负载，单位KB\",\n                    },\n                ],\n                [\n                    {\n                        pointsData: [],\n                        type: 'disk_io',\n                        title: \"磁盘 IO\",\n                        desc: \"磁盘读写负载，单位KB\",\n                        // yAxis: {\n                        //     visible: true,\n                        //     min: 0,\n                        //     max: 1024 * 50,\n                        //     tickCount: 5,\n                        // },\n                    },\n                    {\n                        pointsData: [],\n                        type: 'disk_cap',\n                        title: \"磁盘 容量\",\n                        desc: \"磁盘使用情况，单位GB\",\n                        yAxis: {\n                            visible: true,\n                            min: 0,\n                            max: 100,\n                            tickCount: 5,\n                        },\n                    },\n                ]\n            ],\n        };\n        this.fetchData           = this.fetchData.bind(this);\n        this.fetchCpuData        = this.fetchCpuData.bind(this);\n        this.genQueryTimeRange   = this.genQueryTimeRange.bind(this);\n\n        const oneSecond = 3000;\n        setInterval(this.fetchData, oneSecond);\n    }\n\n    genQueryTimeRange() {\n        const timestampEnd = Math.floor(Date.now() / 1000);\n        const timestampStart = timestampEnd - 5;\n\n        return {\n            start:  timestampStart,\n            end:    timestampEnd,\n            step:   \"1s\",\n        };\n    }\n\n    unixTimestamp2DateFormat(timestamp) {\n        return new Date(timestamp * 1000).Format(\"HH:mm:ss\");\n    }\n\n    stringValue2Int(strValue) {\n        return parseInt(strValue);\n    }\n\n    getResultFromResponse(res) {\n         return res.data.data.result;\n    }\n\n    updateChartData2State(row, rowIdx, col, colIdx, data) {\n        row[colIdx].pointsData = data;\n        this.setState((preState) => {\n            var newState = JSON.parse(JSON.stringify(preState));\n            newState.chartDataArray[rowIdx][colIdx].pointsData = data;\n            return newState;\n        });\n    }\n\n    fetchCpuData(row, rowIdx, col, colIdx) {\n        let timeRange = this.genQueryTimeRange();\n        axios.get(this.state.queryUrl, {\n            params: {\n                ...timeRange,\n                query:  \"100 - (irate(node_cpu_seconds_total{mode=\\\"idle\\\"}[15s]) * 100)\"\n            }\n        })\n            .then( (res) => {\n                var machineResult = this.getResultFromResponse(res);\n\n                const machineDataChart = [];\n                machineResult.forEach((cpuData, cpuIdx) => {\n                    const cpuDataValues = cpuData.values;\n                    const cpuName = cpuData.metric.cpu;\n                    \n                    cpuDataValues.forEach((point) => {\n                        let pointDate = this.unixTimestamp2DateFormat(point[0]);\n                        const cpuUsage = this.stringValue2Int(point[1]);\n                        machineDataChart.push(\n                            {\n                                [this.state.xFieldName]: pointDate,\n                                [this.state.yFieldName]: cpuUsage,\n                                [this.state.seriesField]:\"cpu\" + cpuName,\n                            }\n                        )\n                    })\n                    \n                });\n\n                this.updateChartData2State(row, rowIdx, col, colIdx, machineDataChart);\n            })\n            .catch((err) => {\n                console.log(\"get node metrics failed\", err);\n            });\n    }\n\n    fetchDataParallel(row, rowIdx, col, colIdx, inputs, unitTranslator, labelAppender) {\n        let timeRange = this.genQueryTimeRange();\n\n        const totalPromise = [];\n        inputs.forEach((input) => {\n            totalPromise.push(\n                axios.get(\n                    this.state.queryUrl,\n                    {\n                        params: {\n                            ...timeRange,\n                            query: input.query,\n                        }\n                    })\n            )\n        });\n\n        Promise.all(totalPromise)\n            .then((resArray) => {\n                let totalResult = [];\n\n                console.log(\"resArray\", resArray);\n\n                resArray.forEach((res, resIdx) => {\n                    var machineResult = this.getResultFromResponse(res);\n\n                    machineResult.forEach((dataEle) => {\n                        const cpuDataValues = dataEle.values;\n                        \n                        cpuDataValues.forEach((point) => {\n                            let pointDate = this.unixTimestamp2DateFormat(point[0]);\n                            let value = this.stringValue2Int(point[1]);\n                            \n                            if (unitTranslator != null) {\n                                value = unitTranslator(value);\n                            }\n\n                            let label = inputs[resIdx].label;\n                            if (labelAppender != null) {\n                                let appendLabelPart = labelAppender(dataEle)\n                                if (appendLabelPart != null) {\n                                    label += (\"_\" + appendLabelPart);\n                                }\n                            }\n\n                            totalResult.push(\n                                {\n                                    [this.state.xFieldName]: pointDate,\n                                    [this.state.yFieldName]: value,\n                                    [this.state.seriesField]:label,\n                                }\n                            )\n                        })\n                    });\n                })\n\n                this.updateChartData2State(row, rowIdx, col, colIdx, totalResult);\n            })\n            .catch((err) => {\n                console.log(\"get metrics failed\", err);\n            });\n    }\n\n    fetchMemDataParallel(row, rowIdx, col, colIdx, inputs) {\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024 / 1024),\n            null);\n    }\n\n    fetchMemData(row, rowIdx, col, colIdx) {\n        let machineDataChart = [];\n\n        const inputs = [\n            {\n                query:    \"node_memory_MemTotal_bytes\",\n                label:    \"mem_total\",\n            },\n            {\n                query:      \"node_memory_MemFree_bytes\",\n                label:      \"mem_free\",\n            }\n        ]\n        this.fetchMemDataParallel(row, rowIdx, col, colIdx, inputs, machineDataChart);\n    }\n\n    fetchDiskIODataParallel(row, rowIdx, col, colIdx, inputs) {\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            null,\n            (dataEle) => {\n                if (dataEle.metric.device != null) {\n                    return dataEle.metric.device;\n                }\n                return null;\n            });\n    }\n\n    fetchDiskIOData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"irate(node_disk_written_bytes_total[15s])\",\n                label:    \"written\",\n            },\n            {\n                query:      \"irate(node_disk_read_bytes_total[15s])\",\n                label:      \"read\",\n            },\n            {\n                query:      \"irate(node_textfile_scrape_error[15s])\",\n                label:      \"open_err\",\n            },\n        ]\n        this.fetchDiskIODataParallel(row, rowIdx, col, colIdx, inputs);\n    }\n\n    fetchNetworkIOData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"irate(node_network_receive_bytes_total[15s])\",\n                label:    \"recv\",\n            },\n            {\n                query:    \"irate(node_network_receive_errs_total[15s])\",\n                label:    \"recv_err\",\n            },\n            {\n                query:      \"irate(node_network_transmit_bytes_total[15s])\",\n                label:      \"sent\",\n            },\n            {\n                query:      \"irate(node_network_transmit_errs_total[15s])\",\n                label:      \"sent_err\",\n            }\n        ]\n\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024),\n            (dataEle) => dataEle.metric.device\n        );\n    }\n\n    fetchDiskCapacityData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"node_filesystem_size_bytes\",\n                label:    \"size_total\",\n            },\n            {\n                query:    \"node_filesystem_size_bytes-node_filesystem_avail_bytes\",\n                label:    \"size_used\",\n            },\n            \n        ]\n\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024 / 1024 / 1024),\n            (dataEle) => { console.log(\"disk_cap\", dataEle.metric.device); return dataEle.metric.device;}\n        );\n    }\n\n    fetchData() {\n        this.state.chartDataArray.forEach((row, rowIdx) => {\n            row.forEach((col, colIdx) => {\n                switch (col.type) {\n                    case \"cpu\":         this.fetchCpuData(row, rowIdx, col, colIdx);            break;\n                    case \"mem\":         this.fetchMemData(row, rowIdx, col, colIdx);            break;\n                    case \"disk_io\":     this.fetchDiskIOData(row, rowIdx, col, colIdx);         break;\n                    case \"disk_cap\":    this.fetchDiskCapacityData(row, rowIdx, col, colIdx);   break;\n                    case \"net_io\":      this.fetchNetworkIOData(row, rowIdx, col, colIdx);      break;\n                    \n                    \n                    default:        break;\n                }\n            })\n        })\n    }\n\n    componentDidMount() {\n        this.fetchData();\n    }\n    componentWillUnmount() {\n        \n    }\n\n    render() {\n        const rows = [];\n        for (let i = 0; i < this.state.chartDataArray.length; ++i) {\n            const cols = [];\n            for (let j = 0; j < this.state.chartDataArray[i].length; ++j) {\n                const data = {\n                    xFieldName: this.state.xFieldName,\n                    yFieldName: this.state.yFieldName,\n                    seriesField: this.state.seriesField,\n                    pointsData: this.state.chartDataArray[i][j].pointsData,\n                    title: this.state.chartDataArray[i][j].title,\n                    desc: this.state.chartDataArray[i][j].desc,\n                    yAxis: this.state.chartDataArray[i][j].yAxis,\n                }\n\n                let colKey = \"col_\" + i.toString() + \"_\" + j.toString();\n                cols.push(\n                    <Col key={colKey} span={8} > \n                        <LineChart {...data} />\n                    </Col>\n                )\n            }\n\n            const rowKey = \"row_\" + i.toString();\n            rows.push(\n                <Row key={rowKey} gutter={[16, 16]}>\n                    {cols}\n                </Row>\n            )\n        }\n\n        return (\n            <div>\n                {rows}\n            </div>\n        );\n    }\n}\n\n// 对Date的扩展，将 Date 转化为指定格式的String\n// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， \n// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) \n// 例子： \n// (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423 \n// (new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==> 2006-7-2 8:9:4.18 \nDate.prototype.Format = function (fmt) { //author: meizz \n    var o = {\n        \"M+\": this.getMonth() + 1, //月份 \n        \"d+\": this.getDate(), //日 \n        \"H+\": this.getHours(), //小时 \n        \"m+\": this.getMinutes(), //分 \n        \"s+\": this.getSeconds(), //秒 \n        \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \n        \"S\": this.getMilliseconds() //毫秒 \n    };\n    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (var k in o)\n    if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n    return fmt;\n}\n\nexport default MachinePage;","import React from 'react';\nimport './App.css';\nimport MachinePage from './MachinePage';\n\nfunction App() {\n  return (\n    <MachinePage />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}