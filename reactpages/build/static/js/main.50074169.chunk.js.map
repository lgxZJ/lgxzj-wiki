{"version":3,"sources":["LineChart.js","BulletChart.js","IFrameChild.js","MachinePage.js","App.js","serviceWorker.js","index.js"],"names":["LineChart","xFieldName","this","props","yFieldName","pointsData","config","title","visible","text","description","desc","xField","yField","seriesField","data","padding","forceFit","label","type","point","size","shape","style","fill","stroke","lineWidth","legend","position","yAxis","React","Component","BulletChart","ranges","configData","forEach","element","push","bulletTitle","measures","bulletMeasure","targets","chartTitle","chartDesc","rangeMax","rangeColors","inIFrame","window","location","parent","iframeChangedHandler","height","doc","Math","max","body","scrollHeight","documentElement","console","log","calcPageHeight","document","parentIFrameNode","getElementById","domain","onload","addEventListener","event","html","offsetHeight","clientHeight","source","postMessage","Panel","Collapse","axios","require","default","MachinePage","state","chartDataArray","panelTitle","chartConfigs","queryUrl","chartType","min","tickCount","loading","fetchData","bind","fetchCpuData","genQueryTimeRange","panelChanged","setTimeout","IFrameChangeHandler","timestampEnd","floor","Date","now","start","end","step","idx","toString","timestamp","Format","strValue","parseInt","res","result","row","rowIdx","col","colIdx","setState","preState","newState","JSON","parse","stringify","ele","timeRange","url","updateChartLoading2State","get","params","query","then","machineResult","getResultFromResponse","machineDataChart","cpuData","cpuIdx","cpuDataValues","values","cpuName","metric","cpu","pointDate","unixTimestamp2DateFormat","cpuUsage","stringValue2Int","updateChartData2State","catch","err","inputs","unitTranslator","labelAppender","item","totalPromise","input","eleProcessor","dataEle","resIdx","proc","value","appendLabelPart","Promise","all","resArray","totalResult","parseFloat","itemDataValues","sort","ele1","ele2","fetchDataParallel","fetchMemDataParallel","device","fetchDiskIODataParallel","rowObj","fetchMemData","fetchDiskIOData","fetchDiskCapacityData","fetchNetworkIOData","fetchProcCpuTopData","fetchProcMemTopData","setInterval","rowPanels","i","length","cols","chartConfigRow","j","colKey","chartData","key","span","rowKey","rowIdx2Key","header","gutter","defaultActiveKey","onChange","prototype","fmt","o","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","k","test","replace","RegExp","$1","getFullYear","substr","App","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"iXAsDeA,E,uKAjDP,IAAMC,EAAaC,KAAKC,MAAMF,WACxBG,EAAaF,KAAKC,MAAMC,WACxBC,EAAaH,KAAKC,MAAME,WAKxBC,EAAS,CACXC,MAAO,CACHC,SAAS,EACTC,KAPWP,KAAKC,MAAMI,OAS1BG,YAAa,CACTF,SAAS,EACTC,KAVWP,KAAKC,MAAMQ,MAY1BC,OAAQX,EACRY,OAAQT,EACRU,YAbgBZ,KAAKC,MAAMW,YAc3BC,KAAMV,EAENW,QAAS,OACTC,UAAU,EACVC,MAAO,CACHV,SAAS,EACTW,KAAM,SAEVC,MAAO,CACHZ,SAAS,EACTa,KAAM,EACNC,MAAO,SACPC,MAAO,CACHC,KAAM,QACNC,OAAQ,UACRC,UAAW,IAGnBC,OAAQ,CAAEC,SAAU,aACpBC,MAAO3B,KAAKC,MAAM0B,OAGtB,OACI,6BACI,kBAAC,IAASvB,GADd,S,GA5CYwB,IAAMC,WC4EfC,E,uKA1ET,IACIC,EAAS,CAAE,EAAG,GAAK,IAAM,GAGzBC,EAAa,GACjBhC,KAAKC,MAAMY,KAAKoB,SAAQ,SAAAC,GACtBF,EAAWG,KAAK,CACd9B,MAAO6B,EAAQE,YACfC,SAAU,CAACH,EAAQI,eACnBC,QAAS,CATA,IAUTR,cAIJ,IAAM3B,EAAS,CACXC,MAAO,CACLC,SAAS,EACTC,KAAMP,KAAKC,MAAMuC,YAEnBhC,YAAa,CACXF,SAAS,EACTC,KAAMP,KAAKC,MAAMwC,WAEnB5B,KAAMmB,EACNU,SAtBW,IAuBXC,YAAa,CAAC,UAAW,UAAW,YA2CxC,OACI,kBAAC,IAAWvC,O,GAvEIwB,IAAMC,WCHhC,SAASe,IACL,OAAKC,OAAOC,WAAaD,OAAOE,OAAOD,SAoB3C,SAASE,IACL,GAAKJ,IAAL,CAKA,IAAIK,EAZR,SAAwBC,GACpB,IAAID,EAASE,KAAKC,IAAIF,EAAIG,KAAKC,aAAcJ,EAAIK,gBAAgBD,cAEjE,OADAE,QAAQC,IAAI,UAAWR,GAChBA,EASMS,CAAeC,UAGxBC,EAAmBb,OAAOY,SAASE,eAAe,OAC7B,OAArBD,IACAJ,QAAQC,IAAI,yCAA0CR,GACtDW,EAAiBvC,MAAM4B,OAASA,EAAS,WAVzCO,QAAQC,IAAI,oDAbjBb,MACCe,SAASG,OAAS,cA0BtBjB,OAAOkB,OAASf,EAGhBH,OAAOmB,iBAAiB,WAAW,SAAUC,GAI1C,GAAmB,gBAAfA,EAAMpD,KAAwB,CAQ7B,IAAIwC,EAAOM,SAASN,KAChBa,EAAOP,SAASJ,gBAChBN,EAASE,KAAKC,IAAIC,EAAKC,aAAcD,EAAKc,aAAcD,EAAKE,aAAcF,EAAKZ,aAAcY,EAAKC,cAGvGF,EAAMI,OAAOC,YAAY,CAAE,YAAerB,GAAU,SAI7CD,QCpDPuB,G,OAAUC,IAAVD,OACFE,EAAQC,EAAQ,KAASC,QAEzBC,E,kDACF,WAAY3E,GAAQ,IAAD,8BACf,cAAMA,IACD4E,MAAQ,CACT9E,WAAY,IACZG,WAAY,IACZU,YAAa,OAEbkE,eAAgB,CACZ,CACIC,WAAY,YACZC,aAAc,CACV,CACIC,SAAU,8CACV9E,WAAY,GACZc,KAAM,MACNiE,UAAW,OACX7E,MAAO,mBACPI,KAAM,gDACNkB,MAAO,CACHrB,SAAS,EACT6E,IAAK,EACL/B,IAAK,IACLgC,UAAW,GAEfC,SAAS,GAEb,CACIJ,SAAU,8CACV9E,WAAY,GACZc,KAAM,MACNiE,UAAW,OACX7E,MAAO,4BACPI,KAAM,uEACNkB,MAAO,CACHrB,SAAS,EACT6E,IAAK,EACL/B,IAAK,KACLgC,UAAW,GAEfC,SAAS,KAKrB,CACIN,WAAY,UACZC,aAAc,CACV,CACIC,SAAU,8CACV9E,WAAY,GACZc,KAAM,SACNiE,UAAW,OACX7E,MAAO,kBACPI,KAAM,2DACN4E,SAAS,KAIrB,CACIN,WAAY,iBACZC,aAAc,CACV,CACIC,SAAU,8CACV9E,WAAY,GACZc,KAAM,UACNiE,UAAW,OACX7E,MAAO,kBACPI,KAAM,2DAON4E,SAAS,GAEb,CACIJ,SAAU,8CACV9E,WAAY,GACZc,KAAM,WACNiE,UAAW,OACX7E,MAAO,4BACPI,KAAM,2DACNkB,MAAO,CACHrB,SAAS,EACT6E,IAAK,EACL/B,IAAK,IACLgC,UAAW,GAEfC,SAAS,KAKrB,CACIN,WAAY,kBACZC,aAAc,CACV,CACIC,SAAU,wCACV9E,WAAY,GACZc,KAAM,eACNiE,UAAW,SACX7E,MAAO,uBACPI,KAAM,kEACN4E,SAAS,GAEb,CACIJ,SAAU,wCACV9E,WAAY,GACZc,KAAM,eACNiE,UAAW,SACX7E,MAAO,uBACPI,KAAM,kEACN4E,SAAS,OAO7B,EAAKC,UAAsB,EAAKA,UAAUC,KAAf,gBAC3B,EAAKC,aAAsB,EAAKA,aAAaD,KAAlB,gBAC3B,EAAKE,kBAAsB,EAAKA,kBAAkBF,KAAvB,gBAC3B,EAAKG,aAAsB,EAAKA,aAAaH,KAAlB,gBA3HZ,E,2DA+HfI,WAAWC,EAAqB,O,0CAIhC,IAAMC,EAAe1C,KAAK2C,MAAMC,KAAKC,MAAQ,KAG7C,MAAO,CACHC,MAHmBJ,EAAe,EAIlCK,IAAQL,EACRM,KAAQ,Q,iCAILC,GACP,MAAO,OAASA,EAAIC,a,+CAGCC,GACrB,OAAO,IAAIP,KAAiB,IAAZO,GAAkBC,OAAO,c,sCAG7BC,GACZ,OAAOC,SAASD,K,4CAGEE,GACjB,OAAOA,EAAI7F,KAAKA,KAAK8F,S,4CAGJC,EAAKC,EAAQC,EAAKC,EAAQlG,GAE5Cb,KAAKgH,UAAS,SAACC,GACX,IAAIC,EAAWC,KAAKC,MAAMD,KAAKE,UAAUJ,IACnCK,EAAMJ,EAASpC,eAAe+B,GAAQ7B,aAAa+B,GAGzD,OAFAO,EAAInH,WAAaU,EACjByG,EAAIjC,SAAU,EACP6B,O,+CAIUN,EAAKC,EAAQC,EAAKC,EAAQ1B,GAC/CrF,KAAKgH,UAAS,SAACC,GACX,IAAIC,EAAWC,KAAKC,MAAMD,KAAKE,UAAUJ,IAEzC,OADAC,EAASpC,eAAe+B,GAAQ7B,aAAa+B,GAAQ1B,QAAUA,EACxD6B,O,mCAIFN,EAAKC,EAAQC,EAAKC,GAAS,IAAD,OAC/BQ,EAAYvH,KAAKyF,oBACjB+B,EAAMxH,KAAK6E,MAAMC,eAAe+B,GAAQ7B,aAAa+B,GAAQ9B,SAEjEjF,KAAKyH,yBAAyBb,EAAKC,EAAQC,EAAKC,GAAQ,GAExDtC,EAAMiD,IAAIF,EAAK,CACXG,OAAO,2BACAJ,GADD,IAEFK,MAAQ,oEAGXC,MAAM,SAACnB,GACJ,IAAIoB,EAAgB,EAAKC,sBAAsBrB,GAEzCsB,EAAmB,GACzBF,EAAc7F,SAAQ,SAACgG,EAASC,GAC5B,IAAMC,EAAgBF,EAAQG,OACxBC,EAAUJ,EAAQK,OAAOC,IAE/BJ,EAAclG,SAAQ,SAACf,GAAW,IAAD,EACzBsH,EAAY,EAAKC,yBAAyBvH,EAAM,IAC9CwH,EAAW,EAAKC,gBAAgBzH,EAAM,IAC5C8G,EAAiB7F,MAAjB,mBAES,EAAK0C,MAAM9E,WAAayI,GAFjC,cAGS,EAAK3D,MAAM3E,WAAawI,GAHjC,cAIS,EAAK7D,MAAMjE,YAAa,MAAQyH,GAJzC,UAWR,EAAKO,sBAAsBhC,EAAKC,EAAQC,EAAKC,EAAQiB,MAExDa,OAAM,SAACC,GACJtF,QAAQC,IAAI,0BAA2BqF,Q,wCAMjClC,EAAKC,EAAQC,EAAKC,EAAQgC,EAAQC,EAAgBC,GAAgB,IAAD,OAC3E1B,EAAYvH,KAAKyF,oBACfyD,EAAOlJ,KAAK6E,MAAMC,eAAe+B,GAAQ7B,aAAa+B,GACxDS,EAAM0B,EAAKjE,SAGfjF,KAAKyH,yBAAyBb,EAAKC,EAAQC,EAAKC,GADjC,GAGf,IAAMoC,EAAe,GACrBJ,EAAO9G,SAAQ,SAACmH,GACZD,EAAahH,KACTsC,EAAMiD,IACFF,EACA,CACIG,OAAO,2BACAJ,GADD,IAEFK,MAAOwB,EAAMxB,cAMjC,IAAMyB,EAAe,SAACC,EAASC,EAAQC,EAAMhB,EAAWiB,GAAW,IAAD,EACxC,MAAlBT,IACAS,EAAQT,EAAeS,IAG3B,IAAIzI,EAAQ+H,EAAOQ,GAAQvI,MAC3B,GAAqB,MAAjBiI,EAAuB,CACvB,IAAIS,EAAkBT,EAAcK,GACb,MAAnBI,IACA1I,GAAU,IAAM0I,GAIxB,OAAQR,EAAKjI,MACT,IAAK,eACL,IAAK,eACD,MAAO,CACCmB,YAAaoH,EACblH,cAAemH,GAG3B,QACI,OAAO,EAAP,iBACS,EAAK5E,MAAM9E,WAAayI,GADjC,cAES,EAAK3D,MAAM3E,WAAauJ,GAFjC,cAGS,EAAK5E,MAAMjE,YAAaI,GAHjC,IAQZ2I,QAAQC,IAAIT,GACPtB,MAAK,SAACgC,GACH,IAAIC,EAAc,GAElBD,EAAS5H,SAAQ,SAACyE,EAAK6C,GACC,EAAKxB,sBAAsBrB,GAGjCzE,SAAQ,SAACqH,GACnB,GAAkB,iBAAdJ,EAAKjI,MAAyC,iBAAdiI,EAAKjI,KAAyB,CAC9D,IAAMuI,EAAOF,EAAQhB,OAAOkB,KACxBhB,EAAY,EAAKC,yBAAyBa,EAAQG,MAAM,IACxDA,EAAQM,WAAWT,EAAQG,MAAM,IAErCK,EAAY3H,KAAKkH,EAAaC,EAASC,EAAQC,EAAMhB,EAAWiB,QAC7D,CACH,IAAMO,EAAiBV,EAAQlB,OAG/B4B,EAAe/H,SAAQ,SAACf,GACpB,IAAIsH,EAAY,EAAKC,yBAAyBvH,EAAM,IAChDuI,EAAQ,EAAKd,gBAAgBzH,EAAM,IAEvC4I,EAAY3H,KAAKkH,EAAaC,EAASC,EAN9B,KAM4Cf,EAAWiB,cAM9D,iBAAdP,EAAKjI,MAAyC,iBAAdiI,EAAKjI,OACrCuC,QAAQC,IAAI,gBAAiBqG,GAC7BA,EAAYG,MAAK,SAACC,EAAMC,GACpB,OAAO1D,SAAS0D,EAAK7H,eAAiBmE,SAASyD,EAAK5H,kBAYxDkB,QAAQC,IAAI,eAAgBqG,IAIhC,EAAKlB,sBAAsBhC,EAAKC,EAAQC,EAAKC,EAAQ+C,MAExDjB,OAAM,SAACC,GACJtF,QAAQC,IAAI,qBAAsBqF,Q,2CAIzBlC,EAAKC,EAAQC,EAAKC,EAAQgC,GAC3C/I,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EACAgC,GACA,SAACU,GAAD,OAAWtG,KAAK2C,MAAM2D,EAAQ,KAAO,QACrC,Q,mCAGK7C,EAAKC,EAAQC,EAAKC,GAa3B/G,KAAKqK,qBAAqBzD,EAAKC,EAAQC,EAAKC,EAV7B,CACX,CACIa,MAAU,6BACV5G,MAAU,aAEd,CACI4G,MAAY,4BACZ5G,MAAY,aATG,M,8CAeH4F,EAAKC,EAAQC,EAAKC,EAAQgC,GAC9C/I,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EACAgC,EACA,MACA,SAACO,GACG,OAA6B,MAAzBA,EAAQhB,OAAOgC,OACRhB,EAAQhB,OAAOgC,OAEnB,U,sCAIH1D,EAAKC,EAAQC,EAAKC,GAe9B/G,KAAKuK,wBAAwB3D,EAAKC,EAAQC,EAAKC,EAdhC,CACX,CACIa,MAAU,4CACV5G,MAAU,WAEd,CACI4G,MAAY,yCACZ5G,MAAY,QAEhB,CACI4G,MAAY,yCACZ5G,MAAY,gB,yCAML4F,EAAKC,EAAQC,EAAKC,GAoBjC/G,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EAvBW,CACX,CACIa,MAAU,+CACV5G,MAAU,QAEd,CACI4G,MAAU,8CACV5G,MAAU,YAEd,CACI4G,MAAY,gDACZ5G,MAAY,QAEhB,CACI4G,MAAY,+CACZ5G,MAAY,cAUhB,SAACyI,GAAD,OAAWtG,KAAK2C,MAAM2D,EAAQ,SAC9B,SAACH,GAAD,OAAaA,EAAQhB,OAAOgC,Y,0CAIhB1D,EAAKC,EAAQC,EAAKC,GAOlC/G,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EAVW,CACX,CACIa,MAAU,gBACV5G,MAAU,MASd,SAACyI,GAAD,OAAWA,IACX,Q,0CAIY7C,EAAKC,EAAQC,EAAKC,GAOlC/G,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EAVW,CACX,CACIa,MAAU,gBACV5G,MAAU,MASd,SAACyI,GAAD,OAAWA,IACX,Q,4CAIc7C,EAAKC,EAAQC,EAAKC,GAapC/G,KAAKoK,kBACDxD,EACAC,EACAC,EACAC,EAhBW,CACX,CACIa,MAAU,6BACV5G,MAAU,cAEd,CACI4G,MAAU,yDACV5G,MAAU,eAWd,SAACyI,GAAD,OAAWtG,KAAK2C,MAAM2D,EAAQ,KAAO,KAAO,SAC5C,SAACH,GAAc,OAAOA,EAAQhB,OAAOgC,Y,kCAIhC,IAAD,OACRtK,KAAK6E,MAAMC,eAAe7C,SAAQ,SAACuI,EAAQ3D,GACvC,IAAMD,EAAM4D,EAAOxF,aACnB4B,EAAI3E,SAAQ,SAAC6E,EAAKC,GACd,OAAQD,EAAI7F,MACR,IAAK,MAAe,EAAKuE,aAAaoB,EAAKC,EAAQC,EAAKC,GAAoB,MAC5E,IAAK,MAAe,EAAK0D,aAAa7D,EAAKC,EAAQC,EAAKC,GAAoB,MAC5E,IAAK,UAAe,EAAK2D,gBAAgB9D,EAAKC,EAAQC,EAAKC,GAAiB,MAC5E,IAAK,WAAe,EAAK4D,sBAAsB/D,EAAKC,EAAQC,EAAKC,GAAW,MAC5E,IAAK,SAAe,EAAK6D,mBAAmBhE,EAAKC,EAAQC,EAAKC,GAAc,MAE5E,IAAK,eAAe,EAAK8D,oBAAoBjE,EAAKC,EAAQC,EAAKC,GAAa,MAC5E,IAAK,eAAe,EAAK+D,oBAAoBlE,EAAKC,EAAQC,EAAKC,Y,0CAS3E/G,KAAKsF,YAGLyF,YAAY/K,KAAKsF,UADC,O,+EASlB,IADA,IAAM0F,EAAY,GACTC,EAAI,EAAGA,EAAIjL,KAAK6E,MAAMC,eAAeoG,SAAUD,EAAG,CAKvD,IAJA,IAAME,EAAO,GAEPC,EAAiBpL,KAAK6E,MAAMC,eAAemG,GAAGjG,aAC9CD,EAAa/E,KAAK6E,MAAMC,eAAemG,GAAGlG,WACvCsG,EAAI,EAAGA,EAAID,EAAeF,SAAUG,EAAG,CAC5C,IAAIC,EAAS,OAASL,EAAE5E,WAAa,IAAMgF,EAAEhF,WACzCkF,EAAYH,EAAeC,GAE/B,GAA4B,SAAxBE,EAAUrG,UAAsB,CAChC,IAAMrE,EAAO,CACTd,WAAYC,KAAK6E,MAAM9E,WACvBG,WAAYF,KAAK6E,MAAM3E,WACvBU,YAAaZ,KAAK6E,MAAMjE,YACxBT,WAAYoL,EAAUpL,WACtBE,MAAOkL,EAAUlL,MACjBI,KAAM8K,EAAU9K,KAChBkB,MAAO4J,EAAU5J,OAIrBwJ,EAAKhJ,KACD,kBAAC,IAAD,CAAKqJ,IAAKF,EAAQG,KAAM,IACpB,kBAAC,IAAD,CAAMpL,MAAOkL,EAAUlL,OACjBkL,EAAUlG,QAAU,kBAAC,IAAD,KAAM,kBAAC,EAAcxE,IAAkB,kBAAC,EAAcA,MAM5F,GAA4B,WAAxB0K,EAAUrG,UAAwB,CAClC,IAAM9E,EAAS,CACXS,KAAM0K,EAAUpL,WAChBqC,WAAY+I,EAAUlL,MACtBoC,UAAW8I,EAAU9K,MAEzB0K,EAAKhJ,KACD,kBAAC,IAAD,CAAKqJ,IAAKF,EAAQG,KAAM,IACpB,kBAAC,IAAD,CAAMpL,MAAOkL,EAAUlL,OACjBkL,EAAUlG,QAAU,kBAAC,IAAD,KAAM,kBAAC,EAAgBjF,IAAoB,kBAAC,EAAgBA,OAQtG,IAAMsL,EAAS1L,KAAK2L,WAAWV,GAC/BD,EAAU7I,KACN,kBAACoC,EAAD,CAAOqH,OAAQ7G,EAAYyG,IAAKE,GAC5B,kBAAC,IAAD,CAAKF,IAAKE,EAAQG,OAAQ,CAAC,GAAI,KAC1BV,KAMjB,OACI,6BACI,kBAAC,IAAD,CAAUW,iBAAkB,CAAC9L,KAAK2L,WAAW,IAAKI,SAAU/L,KAAK0F,cAC5DsF,Q,GA3jBKpJ,IAAMC,WAykBhCkE,KAAKiG,UAAUzF,OAAS,SAAU0F,GAC9B,IAAIC,EAAI,CACJ,KAAMlM,KAAKmM,WAAa,EACxB,KAAMnM,KAAKoM,UACX,KAAMpM,KAAKqM,WACX,KAAMrM,KAAKsM,aACX,KAAMtM,KAAKuM,aACX,KAAMpJ,KAAK2C,OAAO9F,KAAKmM,WAAa,GAAK,GACzC,EAAKnM,KAAKwM,mBAGd,IAAK,IAAIC,IADL,OAAOC,KAAKT,KAAMA,EAAMA,EAAIU,QAAQC,OAAOC,IAAK7M,KAAK8M,cAAgB,IAAIC,OAAO,EAAIH,OAAOC,GAAG3B,UACpFgB,EACV,IAAIU,OAAO,IAAMH,EAAI,KAAKC,KAAKT,KAAMA,EAAMA,EAAIU,QAAQC,OAAOC,GAA0B,IAArBD,OAAOC,GAAG3B,OAAiBgB,EAAEO,IAAQ,KAAOP,EAAEO,IAAIM,QAAQ,GAAKb,EAAEO,IAAIvB,UAC5I,OAAOe,GAGIrH,QC3lBAoI,MANf,WACE,OACE,kBAAC,EAAD,OCMgBC,QACW,cAA7BpK,OAAOC,SAASoK,UAEe,UAA7BrK,OAAOC,SAASoK,UAEhBrK,OAAOC,SAASoK,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF3J,SAASE,eAAe,SDyHpB,kBAAmB0J,WACrBA,UAAUC,cAAcC,MACrB5F,MAAK,SAAA6F,GACJA,EAAaC,gBAEd9E,OAAM,SAAA+E,GACLpK,QAAQoK,MAAMA,EAAMC,c","file":"static/js/main.50074169.chunk.js","sourcesContent":["import React from 'react';\nimport { Line } from '@ant-design/charts';\n\nclass LineChart extends React.Component {\n    render() {\n        const xFieldName = this.props.xFieldName;\n        const yFieldName = this.props.yFieldName;\n        const pointsData = this.props.pointsData;\n        const chartTitle = this.props.title;\n        const chartDesc  = this.props.desc;\n        const seriesField = this.props.seriesField;\n\n        const config = {\n            title: {\n                visible: false,\n                text: chartTitle,\n            },\n            description: {\n                visible: true,\n                text: chartDesc,\n            },\n            xField: xFieldName,\n            yField: yFieldName,\n            seriesField,\n            data: pointsData,\n\n            padding: 'auto',\n            forceFit: true,\n            label: {\n                visible: true,\n                type: 'point',\n            },\n            point: {\n                visible: true,\n                size: 2,\n                shape: 'circle',\n                style: {\n                    fill: 'white',\n                    stroke: '#2593fc',\n                    lineWidth: 1,\n                },\n            },\n            legend: { position: 'right-top' },\n            yAxis: this.props.yAxis,\n        };\n\n        return (\n            <div>\n                <Line {...config} />;\n            </div>\n        );\n    }\n}\n\nexport default LineChart;","import React from 'react';\nimport { Bullet } from '@ant-design/charts';\n\nclass BulletChart extends React.Component {\n    render() {\n      let target = 85;\n      let ranges = [ 0, 0.5, 0.85, 1 ];\n      let rangeMax = 100;\n\n      let configData = [];\n      this.props.data.forEach(element => {\n        configData.push({\n          title: element.bulletTitle,\n          measures: [element.bulletMeasure],\n          targets: [target],\n          ranges,\n        })\n      });\n      \n      const config = {\n          title: {\n            visible: false,\n            text: this.props.chartTitle,\n          },\n          description: {\n            visible: true,\n            text: this.props.chartDesc,\n          },\n          data: configData,\n          rangeMax,\n          rangeColors: ['#B4EBBF', '#FFDBA2', '#FFB1AC'],\n          // legend: {\n          //   custom: true,\n          //   items: [\n          //     {\n          //       name: '实际进度',\n          //       marker: {\n          //         symbol: 'square',\n          //         style: { fill: '#5B8FF9' },\n          //       },\n          //     },\n          //     {\n          //       name: '目标值',\n          //       marker: {\n          //         symbol: 'line',\n          //         style: { stroke: '#5B8FF9' },\n          //       },\n          //     },\n          //     {\n          //       name: '差',\n          //       marker: {\n          //         symbol: 'square',\n          //         style: { fill: '#FFB1AC' },\n          //       },\n          //     },\n          //     {\n          //       name: '良',\n          //       marker: {\n          //         symbol: 'square',\n          //         style: { fill: '#FFDBA2' },\n          //       },\n          //     },\n          //     {\n          //       name: '优',\n          //       marker: {\n          //         symbol: 'square',\n          //         style: { fill: '#B4EBBF' },\n          //       },\n          //     },\n          //   ],\n          // },\n        };\n\n      return (\n          <Bullet {...config} />\n      )\n    }\n}\n\nexport default BulletChart;","function inIFrame() { \n    if ( window.location !== window.parent.location ) { \n        return true;\n    } else { \n        return false;\n    } \n}\n\n//  use document.domain to implement cross-domain refs\n// eslint-disable-next-line no-restricted-globals\nif(inIFrame()) {\n    document.domain = 'lgxzj.wiki'\n}\n\n// 计算页面的实际高度，iframe自适应会用到\nfunction calcPageHeight(doc) {\n    var height = Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight);\n    console.log(\"height:\", height);\n    return height;\n}\n\nfunction iframeChangedHandler() {\n    if (!inIFrame()) {\n        console.log(\"not inside iframe, no need to change iframe size\");\n        return;\n    }\n\n    var height = calcPageHeight(document)\n    \n    // eslint-disable-next-line no-restricted-globals\n    var parentIFrameNode = parent.document.getElementById('ifr');\n    if (parentIFrameNode !== null) {\n        console.log(\"changing parent iframe('ifr') to size:\", height);\n        parentIFrameNode.style.height = height + 'px';\n    }\n}\n\nwindow.onload = iframeChangedHandler;\n\n//  TODO: remove this\nwindow.addEventListener('message', function (event) {\n\n    // Need to check for safety as we are going to process only our messages\n    // So Check whether event with data(which contains any object) contains our message here its \"FrameHeight\"\n   if (event.data === \"FrameHeight\") {\n\n        //event.source contains parent page window object \n        //which we are going to use to send message back to main page here \"abc.com/page\"\n\n        //parentSourceWindow = event.source;\n\n        //Calculate the maximum height of the page\n        var body = document.body;\n        var html = document.documentElement;\n        var height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n\n       // Send height back to parent page \"abc.com/page\"\n        event.source.postMessage({ \"FrameHeight\": height }, \"*\");       \n    }\n});\n\nexport default iframeChangedHandler;","import React from 'react';\nimport { Row, Col,Spin, Collapse, Card } from 'antd';\n\nimport LineChart from './LineChart';\nimport BulletChart from './BulletChart';\nimport IFrameChangeHandler from './IFrameChild';\n\nimport 'antd/dist/antd.css';\n\nconst { Panel } = Collapse;\nconst axios = require('axios').default;\n\nclass MachinePage extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            xFieldName: \"x\",\n            yFieldName: \"y\",\n            seriesField: 'type',\n            \n            chartDataArray: [\n                {\n                    panelTitle: 'Cpu & Mem',\n                    chartConfigs: [\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n                            pointsData: [],\n                            type: 'cpu',\n                            chartType: 'line',\n                            title: \"CPU 负载\",\n                            desc: \"按cpu分组的负载率\",\n                            yAxis: {\n                                visible: true,\n                                min: 0,\n                                max: 110,\n                                tickCount: 5,\n                            },\n                            loading: true,\n                        },\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n                            pointsData: [],\n                            type: 'mem',\n                            chartType: 'line',\n                            title: \"内存 负载\",\n                            desc: \"内存资源使用情况，单位MB\",\n                            yAxis: {\n                                visible: true,\n                                min: 0,\n                                max: 4400,\n                                tickCount: 5,\n                            },\n                            loading: true,\n                        },\n                        \n                    ],\n                },\n                {\n                    panelTitle: 'Network',\n                    chartConfigs: [\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n                            pointsData: [],\n                            type: 'net_io',\n                            chartType: 'line',\n                            title: \"网络 IO\",\n                            desc: \"网络收发负载，单位KB\",\n                            loading: true,\n                        },\n                    ],\n                },\n                {\n                    panelTitle: 'Disk IO & Caps',\n                    chartConfigs: [\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n                            pointsData: [],\n                            type: 'disk_io',\n                            chartType: 'line',\n                            title: \"磁盘 IO\",\n                            desc: \"磁盘读写负载，单位KB\",\n                            // yAxis: {\n                            //     visible: true,\n                            //     min: 0,\n                            //     max: 1024 * 50,\n                            //     tickCount: 5,\n                            // },\n                            loading: true,\n                        },\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query_range\",\n                            pointsData: [],\n                            type: 'disk_cap',\n                            chartType: 'line',\n                            title: \"磁盘 容量\",\n                            desc: \"磁盘使用情况，单位GB\",\n                            yAxis: {\n                                visible: true,\n                                min: 0,\n                                max: 100,\n                                tickCount: 5,\n                            },\n                            loading: true,\n                        },\n                        \n                    ],\n                },\n                {\n                    panelTitle: 'Proc Intensives',\n                    chartConfigs: [\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query\",\n                            pointsData: [],\n                            type: 'proc_top_cpu',\n                            chartType: 'bullet',\n                            title: \"CPU活跃TOP10\",\n                            desc: \"CPU活跃进程，单位百分比\",\n                            loading: true,\n                        },\n                        {\n                            queryUrl: \"http://metric.lgxzj.wiki/api/v1/query\",\n                            pointsData: [],\n                            type: 'proc_top_mem',\n                            chartType: 'bullet',\n                            title: \"MEM活跃TOP10\",\n                            desc: \"CPU活跃进程，单位百分比\",\n                            loading: true,\n                        }\n                    ]\n                },\n                \n            ],\n        };\n        this.fetchData           = this.fetchData.bind(this);\n        this.fetchCpuData        = this.fetchCpuData.bind(this);\n        this.genQueryTimeRange   = this.genQueryTimeRange.bind(this);\n        this.panelChanged        = this.panelChanged.bind(this);\n    }\n\n    panelChanged() {\n        setTimeout(IFrameChangeHandler, 500);;\n    }\n\n    genQueryTimeRange() {\n        const timestampEnd = Math.floor(Date.now() / 1000);\n        const timestampStart = timestampEnd - 5;\n\n        return {\n            start:  timestampStart,\n            end:    timestampEnd,\n            step:   \"1s\",\n        };\n    }\n\n    rowIdx2Key(idx) {\n        return \"row_\" + idx.toString();\n    }\n\n    unixTimestamp2DateFormat(timestamp) {\n        return new Date(timestamp * 1000).Format(\"HH:mm:ss\");\n    }\n\n    stringValue2Int(strValue) {\n        return parseInt(strValue);\n    }\n\n    getResultFromResponse(res) {\n         return res.data.data.result;\n    }\n\n    updateChartData2State(row, rowIdx, col, colIdx, data) {\n        //row[colIdx].pointsData = data;\n        this.setState((preState) => {\n            var newState = JSON.parse(JSON.stringify(preState));\n            const ele = newState.chartDataArray[rowIdx].chartConfigs[colIdx];\n            ele.pointsData = data;\n            ele.loading = false;\n            return newState;\n        });\n    }\n\n    updateChartLoading2State(row, rowIdx, col, colIdx, loading) {\n        this.setState((preState) => {\n            var newState = JSON.parse(JSON.stringify(preState));\n            newState.chartDataArray[rowIdx].chartConfigs[colIdx].loading = loading;\n            return newState;\n        });\n    }\n\n    fetchCpuData(row, rowIdx, col, colIdx) {\n        let timeRange = this.genQueryTimeRange();\n        let url = this.state.chartDataArray[rowIdx].chartConfigs[colIdx].queryUrl;\n\n        this.updateChartLoading2State(row, rowIdx, col, colIdx, true);\n\n        axios.get(url, {\n            params: {\n                ...timeRange,\n                query:  \"100 - (irate(node_cpu_seconds_total{mode=\\\"idle\\\"}[15s]) * 100)\"\n            }\n        })\n            .then( (res) => {\n                var machineResult = this.getResultFromResponse(res);\n\n                const machineDataChart = [];\n                machineResult.forEach((cpuData, cpuIdx) => {\n                    const cpuDataValues = cpuData.values;\n                    const cpuName = cpuData.metric.cpu;\n                    \n                    cpuDataValues.forEach((point) => {\n                        let pointDate = this.unixTimestamp2DateFormat(point[0]);\n                        const cpuUsage = this.stringValue2Int(point[1]);\n                        machineDataChart.push(\n                            {\n                                [this.state.xFieldName]: pointDate,\n                                [this.state.yFieldName]: cpuUsage,\n                                [this.state.seriesField]:\"cpu\" + cpuName,\n                            }\n                        )\n                    })\n                    \n                });\n\n                this.updateChartData2State(row, rowIdx, col, colIdx, machineDataChart);\n            })\n            .catch((err) => {\n                console.log(\"get node metrics failed\", err);\n            });\n    }\n\n\n\n    fetchDataParallel(row, rowIdx, col, colIdx, inputs, unitTranslator, labelAppender) {\n        let timeRange = this.genQueryTimeRange();\n        const item = this.state.chartDataArray[rowIdx].chartConfigs[colIdx];\n        let url = item.queryUrl;\n\n        let loading  = true;\n        this.updateChartLoading2State(row, rowIdx, col, colIdx, loading);\n\n        const totalPromise = [];\n        inputs.forEach((input) => {\n            totalPromise.push(\n                axios.get(\n                    url,\n                    {\n                        params: {\n                            ...timeRange,\n                            query: input.query,\n                        }\n                    })\n            )\n        });\n\n        const eleProcessor = (dataEle, resIdx, proc, pointDate, value) => {\n            if (unitTranslator != null) {\n                value = unitTranslator(value);\n            }\n\n            let label = inputs[resIdx].label;\n            if (labelAppender != null) {\n                let appendLabelPart = labelAppender(dataEle)\n                if (appendLabelPart != null) {\n                    label += (\"_\" + appendLabelPart);\n                }\n            }\n            \n            switch (item.type) {\n                case 'proc_top_mem':\n                case 'proc_top_cpu':\n                    return {\n                            bulletTitle: proc,\n                            bulletMeasure: value,\n                    };\n                    \n                default:\n                    return {\n                            [this.state.xFieldName]: pointDate,\n                            [this.state.yFieldName]: value,\n                            [this.state.seriesField]:label,\n                    };\n            }\n        }\n\n        Promise.all(totalPromise)\n            .then((resArray) => {\n                let totalResult = [];\n\n                resArray.forEach((res, resIdx) => {\n                    var machineResult = this.getResultFromResponse(res);\n                    \n\n                    machineResult.forEach((dataEle) => {\n                        if (item.type === 'proc_top_cpu' || item.type === 'proc_top_mem') {\n                            const proc = dataEle.metric.proc;\n                            let pointDate = this.unixTimestamp2DateFormat(dataEle.value[0]);\n                            let value = parseFloat(dataEle.value[1]);\n\n                            totalResult.push(eleProcessor(dataEle, resIdx, proc, pointDate, value));\n                        } else {\n                            const itemDataValues = dataEle.values;\n                            const proc = null;\n                            \n                            itemDataValues.forEach((point) => {\n                                let pointDate = this.unixTimestamp2DateFormat(point[0]);\n                                let value = this.stringValue2Int(point[1]);\n                                \n                                totalResult.push(eleProcessor(dataEle, resIdx, proc, pointDate, value));\n                            });\n                        }\n                    });\n                })\n\n                if (item.type === 'proc_top_cpu' || item.type === 'proc_top_mem') {\n                    console.log(\"before update\", totalResult);\n                    totalResult.sort((ele1, ele2) => {\n                        return parseInt(ele2.bulletMeasure) - parseInt(ele1.bulletMeasure);\n                    });\n                    // if (totalResult.length < 10) {\n                    //     let j = 0;\n                    //     let len = 10 - totalResult.length;\n                    //     for (j = 0; j < len; ++j) {\n                    //         totalResult.push({\n                    //             bulletTitle: '无',\n                    //             bulletMeasure: 0,\n                    //         });\n                    //     }\n                    // }\n                    console.log(\"after update\", totalResult);\n                }\n                \n                \n                this.updateChartData2State(row, rowIdx, col, colIdx, totalResult);\n            })\n            .catch((err) => {\n                console.log(\"get metrics failed\", err);\n            });\n    }\n\n    fetchMemDataParallel(row, rowIdx, col, colIdx, inputs) {\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024 / 1024),\n            null);\n    }\n\n    fetchMemData(row, rowIdx, col, colIdx) {\n        let machineDataChart = [];\n\n        const inputs = [\n            {\n                query:    \"node_memory_MemTotal_bytes\",\n                label:    \"mem_total\",\n            },\n            {\n                query:      \"node_memory_MemFree_bytes\",\n                label:      \"mem_free\",\n            }\n        ]\n        this.fetchMemDataParallel(row, rowIdx, col, colIdx, inputs, machineDataChart);\n    }\n\n    fetchDiskIODataParallel(row, rowIdx, col, colIdx, inputs) {\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            null,\n            (dataEle) => {\n                if (dataEle.metric.device != null) {\n                    return dataEle.metric.device;\n                }\n                return null;\n            });\n    }\n\n    fetchDiskIOData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"irate(node_disk_written_bytes_total[15s])\",\n                label:    \"written\",\n            },\n            {\n                query:      \"irate(node_disk_read_bytes_total[15s])\",\n                label:      \"read\",\n            },\n            {\n                query:      \"irate(node_textfile_scrape_error[15s])\",\n                label:      \"open_err\",\n            },\n        ]\n        this.fetchDiskIODataParallel(row, rowIdx, col, colIdx, inputs);\n    }\n\n    fetchNetworkIOData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"irate(node_network_receive_bytes_total[15s])\",\n                label:    \"recv\",\n            },\n            {\n                query:    \"irate(node_network_receive_errs_total[15s])\",\n                label:    \"recv_err\",\n            },\n            {\n                query:      \"irate(node_network_transmit_bytes_total[15s])\",\n                label:      \"sent\",\n            },\n            {\n                query:      \"irate(node_network_transmit_errs_total[15s])\",\n                label:      \"sent_err\",\n            }\n        ]\n\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024),\n            (dataEle) => dataEle.metric.device\n        );\n    }\n\n    fetchProcCpuTopData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"ps_pusher_cpu\",\n                label:    \"\",\n            }\n        ];\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => value,\n            null\n        );\n    }\n\n    fetchProcMemTopData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"ps_pusher_mem\",\n                label:    \"\",\n            }\n        ];\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => value,\n            null\n        );\n    }\n\n    fetchDiskCapacityData(row, rowIdx, col, colIdx) {\n        const inputs = [\n            {\n                query:    \"node_filesystem_size_bytes\",\n                label:    \"size_total\",\n            },\n            {\n                query:    \"node_filesystem_size_bytes-node_filesystem_avail_bytes\",\n                label:    \"size_used\",\n            },\n            \n        ]\n\n        this.fetchDataParallel(\n            row, \n            rowIdx, \n            col, \n            colIdx, \n            inputs, \n            (value) => Math.floor(value / 1024 / 1024 / 1024),\n            (dataEle) => { return dataEle.metric.device;}\n        );\n    }\n\n    fetchData() {\n        this.state.chartDataArray.forEach((rowObj, rowIdx) => {\n            const row = rowObj.chartConfigs;\n            row.forEach((col, colIdx) => {\n                switch (col.type) {\n                    case \"cpu\":         this.fetchCpuData(row, rowIdx, col, colIdx);            break;\n                    case \"mem\":         this.fetchMemData(row, rowIdx, col, colIdx);            break;\n                    case \"disk_io\":     this.fetchDiskIOData(row, rowIdx, col, colIdx);         break;\n                    case \"disk_cap\":    this.fetchDiskCapacityData(row, rowIdx, col, colIdx);   break;\n                    case \"net_io\":      this.fetchNetworkIOData(row, rowIdx, col, colIdx);      break;\n                    \n                    case 'proc_top_cpu':this.fetchProcCpuTopData(row, rowIdx, col, colIdx);     break;\n                    case 'proc_top_mem':this.fetchProcMemTopData(row, rowIdx, col, colIdx);     break;\n                    \n                    default:        break;\n                }\n            })\n        })\n    }\n\n    componentDidMount() {\n        this.fetchData();\n\n        const oneSecond = 3000;\n        setInterval(this.fetchData, oneSecond);\n    }\n    componentWillUnmount() {\n        \n    }\n\n    render() {\n        const rowPanels = [];\n        for (let i = 0; i < this.state.chartDataArray.length; ++i) {\n            const cols = [];\n\n            const chartConfigRow = this.state.chartDataArray[i].chartConfigs;\n            const panelTitle = this.state.chartDataArray[i].panelTitle;\n            for (let j = 0; j < chartConfigRow.length; ++j) {\n                let colKey = \"col_\" + i.toString() + \"_\" + j.toString();\n                let chartData = chartConfigRow[j];\n\n                if (chartData.chartType === 'line') {\n                    const data = {\n                        xFieldName: this.state.xFieldName,\n                        yFieldName: this.state.yFieldName,\n                        seriesField: this.state.seriesField,\n                        pointsData: chartData.pointsData,\n                        title: chartData.title,\n                        desc: chartData.desc,\n                        yAxis: chartData.yAxis,\n                    }\n    \n                    \n                    cols.push(\n                        <Col key={colKey} span={12} > \n                            <Card title={chartData.title}>\n                                { chartData.loading ? <Spin><LineChart {...data} /></Spin> : <LineChart {...data} /> }\n                            </Card>\n                            \n                        </Col>\n                    );\n                }\n                if (chartData.chartType === 'bullet') {\n                    const config = {\n                        data: chartData.pointsData,\n                        chartTitle: chartData.title,\n                        chartDesc: chartData.desc,\n                    };\n                    cols.push(\n                        <Col key={colKey} span={12} > \n                            <Card title={chartData.title}>\n                                { chartData.loading ? <Spin><BulletChart {...config} /></Spin> : <BulletChart {...config} /> }\n                            </Card>    \n                        </Col>\n                    )\n                }\n            \n            }\n\n            const rowKey = this.rowIdx2Key(i);\n            rowPanels.push(\n                <Panel header={panelTitle} key={rowKey}>\n                    <Row key={rowKey} gutter={[16, 16]}>\n                        {cols}\n                    </Row>\n                </Panel>\n            )\n        }\n\n        return (\n            <div>\n                <Collapse defaultActiveKey={[this.rowIdx2Key(0)]} onChange={this.panelChanged} >\n                    {rowPanels}\n                </Collapse>\n                \n            </div>\n        );\n    }\n}\n\n// 对Date的扩展，将 Date 转化为指定格式的String\n// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， \n// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) \n// 例子： \n// (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423 \n// (new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==> 2006-7-2 8:9:4.18 \nDate.prototype.Format = function (fmt) { //author: meizz \n    var o = {\n        \"M+\": this.getMonth() + 1, //月份 \n        \"d+\": this.getDate(), //日 \n        \"H+\": this.getHours(), //小时 \n        \"m+\": this.getMinutes(), //分 \n        \"s+\": this.getSeconds(), //秒 \n        \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \n        \"S\": this.getMilliseconds() //毫秒 \n    };\n    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (var k in o)\n    if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n    return fmt;\n}\n\nexport default MachinePage;","import React from 'react';\nimport './App.css';\nimport MachinePage from './MachinePage';\n\nfunction App() {\n  return (\n    <MachinePage />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}